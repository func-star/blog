---
title: 监听者模式实战应用
date: 2018-08-24 20:11:41
tags:
---

### 概述
监听者模式其实就是一种简单的前端思维模式，在前端领域遍地都是。
当它被应用到合适的场景下你就会感受到它的魅力。

下面我们拿商品曝光打点起个头来讲述一下监听者模式可以怎么来应用。

### 性能比较差的商品曝光方法
在互联网电商领域，商品曝光打点可以说再平常不过了，我们需要通过商品的曝光度，来合理的安排商品主推等等。
那么这东西可以怎么实现呢？
一些同学可能会立马说，在页面滚动的时候去拿到每一个商品类目，再判断是不是已经处在屏幕内，然后上报接口嘛！！！
当然这样做肯定能达到商品曝光的目的，但是会不会存在什么隐患或者性能问题呢？
我们可以看出如果每次滚动都去拿一遍商品类目，每次都需要遍历访问一次 dom，然后每次都还需要拿到节点的 `scrollTop `，这样就又触发了浏览器的重排重绘（重排重绘可是性能杀手哈😂）。

### 换个角度想问题
我们现在来分析一下，这样的方式问题出在哪几个点：
1. 每次滚动的时候你都需要遍历子节点 , `dom`操作的开销可是非常大的，更何况那么的频繁，而且已经曝光的点也会被你遍历取到，数据量一大的话~~~
2. 判断节点是否需要曝光的时候都需要实时取一遍位置信息，这样就又触发了重排重绘，而且每次都需要取，好可怕~~

接下来我们就针对这几个点来分析一下：
- 针对第一个点，我们可以变更一下思路，将节点信息格式化初始化的时候找个数组存储起来。然后后续滚动触发的时候就只是简单的遍历这个数组，并且已经成功打点的项就从数组中删除，如此这个数组的长度就是可控的
- 针对第二点，我们可以只在初始化的时候读取一次scrollTop，同样插入到被格式化的节点数据中。然后后续都从节点数据中取，这样就大幅减少重排重绘

分析到这里，好像已经比较之前的方式优美了不少，性能也优化了很多。但是我们还是需要每次都遍历一个数组去循环判断是否曝光，而且数组如果是动态(像下拉加载分页这样)的话，可能代码就会变的不怎么优美。那么有没有什么办法可以让代码更优美呢？接下来来介绍一下监听者模式的应用~~

### 监听者模式介绍
听到监听者模式，大家第一反应应该是事件系统，说的简单一点就是消息的订阅和分发。[mona-events](https://www.npmjs.com/package/mona-events)这是一个简单的`JS`事件体系。
举一个🌰：
假设有一天你的老大突然想出去吃顿好的，然后在微信群里就吼了一声说：“你们谁要跟我出去一起吃饭吗？”
员工A：“我要回家吃饭，我不去。”
员工B：“我去的。”
员工C：“我要加班，我不去。”
...
这就是一个监听者模式的引用了哈😁😁😁

接下来我们再来举一个例子对比一下：
同样还是你的老大突然想出去吃饭，不过这次不是在微信群里了，他是挨个挨个的问了一遍，然后问了30个人终于找到两个人陪他出去吃饭了～～

### 让我们为商品曝光打点提升一下幸福感
现在我们在每一个商品节点加载结束的时候就对这个商品绑定一个事件。
然后当页面滚动的时候，只需要在全局📢一个通知，告知商品页面滚动了，商品自己判断自己需不需要进行曝光。
并且节点有自己的行为，跟容器节点相互独立，因此就不需要考虑分页这些会带来的问题。

#### 步骤：
- 商品节点自觉的进行滚动事件`命名：scroll-emit-event`监听，并存储节点`scrollTop`值
- 容器滚动的时候分发`scroll-emit-event`消息通知
- 商品节点自行判断是否满足曝光条件


### 感受到简单的幸福之后，当然要更幸福啦
接下来我们通过几个点来更好的优化一下：
- 页面滚动当然要进行节流啦，你可以设置一个`200ms` 的`setTimeout`哟
- 商品上报曝光接口成功之后就要取消掉自个儿的监听哈

介绍完这些之后大家可以联想一下，图片懒加载、页面按需加载这些都可以按照这个套路来实现

#### 这里准备了两个demo

- [Mona系列 - React滚动监听组件](https://www.npmjs.com/package/mor-scroll-watcher)
> 这是我抽象出来的一个滚动监听组件

- [Mona系列-React图片懒加载](https://www.npmjs.com/package/mor-lazyload-img)
> 这是基于 [Mona系列 - React滚动监听组件](https://www.npmjs.com/package/mor-scroll-watcher) 实现的一个图片懒加载组件

### 将监听者模式跟业务相结合
经过上面的介绍之后，对事件应用有了一定的了解，那么如何更具艺术性的在业务中使用，让我们的代码更加清晰可维护呢？

![1](http://static.monajs.cn/example/events.gif)

这是一个在日常开发中非常常见的场景，通过弹层来进行一些操作，然后同步更新页面数据

我们通常会通过将更新页面数据的一个执行回调传递到弹层模块中去，然后在弹层操作成功之后执行

这样做自然没有什么问题，但是随着业务的复杂度提升，我们可能需要传递的执行回调就会越来越多，层级可能就不再是简单的父子级关系
我们可以预见我们即将碰到跨很多级传递回调函数的场景，代码即将变的难以维护

接下来我们来讨论一个比较巧妙的方式：
```js
// baseServer.js
import Events from 'mona-events';
export default class BaseServer extends Events {}
```

```js
// server.js
import BaseServer from 'core/baseServer'

class TestServer extends BaseServer {
	test () {
		return new Promise((resolve, reject) => {
                        //  模拟后端接口请求
			setTimeout(() => {
				resolve('你的模样')
			}, 1000)
		}).then(res => {
			this.emit('changeText', res)
			return res
		})
	}
}

export default new TestServer
```
```js
// page.jsx
...
componentWillMount () {
	TestServer.on('changeText', res => {
		this.text = res
		this.setState({})
	})
}
...
```
```js
// modal.jsx
...
handleOk () {
	this.loading = true
	this.setState({})
	TestServer.test().then(() => {
		this.loading = false
		Notification.info({
			message: '文案修改成功！'
		})
		this.visible = false
		this.setState({})
	})

}
...
```

通过代码我们可以看到，我们将监听者模式跟后端请求接口巧妙的结合在了一起
当弹层上的操作请求成功返回之后我们分发一个`changeText`事件，页面收到这个消息之后就触发了更改页面信息的操作

✨✨这样就巧妙的避免了多级传递执行回调的问题，而且可以在任何地方触发`changeText`事件，规避掉了很多冗余的重复逻辑，代码自然就变的简单了

注意一点：这里介绍了这种方法不代表所有这种场景都用这种方式，简单的父子级关系当然是直接传递参数比较简单易读

> 之所以优美，是因为应用在了它最合适的场景

监听者模式还可以应用在各种复杂的场景，大家可以自己慢慢探索
这篇文章主要是为了提供一个前端思维模式，代码仅供参考
